var path = require('path'), XMLUtil = require("../../utils/xmlUtil"), ResourceUtil = require("../../utils/resourceUtil");
//this file contains the object type implementation for the parameters of an attribute
/**
* attrParam is used in IOMap Translation into Attribute Value Map
* it has info user uploadde values
*/
function attrParam(attrName, attrObject, stepUIState, skillobject, IOMapRef) {
    this.attrName = attrName;
    this.attrObject = attrObject;
    this.stepUIState = stepUIState;
    this.skillobject = skillobject;
}
/**
* attrTaskParam is used in IOMap Translation into Attribute Value Map
* it has info pertaining to task and step
*/
function attrTaskParam(taskId, stepIndex, stateId, dbFilestoreMgr, resourceMap) {
    this.taskId = taskId;
    this.stepIndex = stepIndex;
    this.stateId = stateId;
    this.dbFilestoreMgr = dbFilestoreMgr;
    this.resourceMap = resourceMap;
}
/**
 * @param {*} resourceType : It can have following two values and according to that the source folder
 * from which the file needs to be copied from is evaluated
 *    skill: Means that the resource is skill specific and has to be copied from "filestore/skills/" folder
 *    step: Means that the resource is task specific and has to be copied from "filestore/resources/" folder
 * @param {*} filePath : The file path fetched from IOMap JSON
 * when resourcetype is step => Ex: "GO16.WD.12.12B.02.T1/1/1493790231823.DocumentData.json"
 * when resourcetype is skill => Ex: "xl/movecellcontent/resources/tree.xml"
 * @param {*} customParentFolder : Any custom parent folder hierarchy after the 'Assets' folder
 */
attrTaskParam.prototype.addResourceToMap = function (resourceType, filePath, customParentFolder) {
    if (customParentFolder === void 0) { customParentFolder = ""; }
    var existingResource = this.resourceMap[filePath];
    if (existingResource)
        return existingResource;
    var fileName = ResourceUtil.getFileNameWithExtension(filePath), fileType = ResourceUtil.getFileType(fileName), stepAssetsFolderPath = XMLUtil.genStepAssetsFolderPath(this.taskId, this.stepIndex), 
    // Replacing all occurance of '\' with '/' because '\' is used as an escape character in Javascript
    absFilePath = path.join(stepAssetsFolderPath, customParentFolder, fileName).replace(/\\/g, "/");
    resourceType = resourceType.toLowerCase();
    if (resourceType !== "skill")
        resourceType = "step";
    //Pushing to  Resource Map so that the file can be copied asynchronously
    this.resourceMap[filePath] = { customParentFolder: customParentFolder, fileName: fileName, resourceType: resourceType, absFilePath: absFilePath, fileType: fileType };
    return { customParentFolder: customParentFolder, fileName: fileName, stepAssetsFolderPath: stepAssetsFolderPath, fileType: fileType, absFilePath: absFilePath };
};
var IOTranslator = (function () {
    function IOTranslator() {
    }
    IOTranslator.prototype.genPromise = function (attrParams, taskParam) {
        var self = this;
        return new Promise(function (resolve, reject) {
            self.evaluateAttribute(attrParams, taskParam).then(function (resolveParams) {
                resolve(resolveParams);
            }, function (error) {
                console.log("promise rejection at genPromise");
                reject(error);
            });
        });
    };
    //common function for getting the param array for the passed array of params
    IOTranslator.prototype.getEvaluatedParams = function (paramObj, stepUIState) {
        var evalexp = "stepUIState.";
        // var finalArray = [];
        for (var param in paramObj) {
            paramObj[param] = eval(evalexp + paramObj[param]);
        }
        return paramObj;
    };
    IOTranslator.prototype.evaluateFromFunc = function (attrParams, paramsObj, taskParams) {
        var functionName = attrParams.attrObject["function-name"];
        if (!attrParams.skillobject[functionName]) {
            functionName = "extractSingleParamVal";
        }
        var skillParams = { paramsObj: paramsObj, taskParams: taskParams };
        return attrParams.skillobject[functionName](skillParams);
    };
    IOTranslator.prototype.evaluateAttribute = function (attrParams, taskParam) {
        var evaluatedParams = [];
        var attrObjectValue = "";
        //the attr params currentky contains the string values , the LOC below converts it into values from the Step UI Json 
        evaluatedParams = this.getEvaluatedParams(attrParams.attrObject.params, attrParams.stepUIState);
        return this.evaluateFromFunc(attrParams, evaluatedParams, taskParam);
    };
    /**
     * returns the promise which fills the value of an individual attribute
     * using stepUIState in the corresponding node of IOMap
     * @param {*} attrObj : it's an object having the following
     * IOMap, stepUIState,
     * skillRef (object of skill specific class. It was generated by skill factory),
     * taskId, stepIndex and reference of dbFilestoreMgr
     * @param {*} data : it's an object having four values which are parentObj, keyName, stateId and compId
     * @param {*} PromiseRequestsArr : An array in which promise object has to be pushed.
     * Later on in the execution cycle this whole array is passed to the Promise.All()
     * @param {*} resourceMap : An Object which contains the info of the Resources that will to be copied
     * to corresponding folder and added in the preload Resources Array which will be used in XML generation
     */
    IOTranslator.prototype._executeIOMapFunction = function (attrObj, data, PromiseRequestsArr, resourceMap) {
        var attrParams = new attrParam(data.keyName, data.parentObj[data.keyName], attrObj.stepUIState, attrObj.skillRef), taskParam = new attrTaskParam(attrObj.taskId, attrObj.stepIndex, data.stateId, attrObj.dbFilestoreMgr, resourceMap);
        PromiseRequestsArr.push(this.genPromise(attrParams, taskParam).then(function (resolveParams) {
            data.parentObj[data.keyName] = resolveParams.attrValue;
            // this if check here is for backward compatibility
            // in the new implementation skill class need not send this preload resource array here
            // this code will become obsolete once all the present templates start using new approach
            if (resolveParams.preloadResArr) {
                if (!attrObj.IOMap.preload)
                    attrObj.IOMap.preload = { resource: [] };
                else if (!attrObj.IOMap.preload.resource)
                    attrObj.IOMap.preload.resource = [];
                (_a = attrObj.IOMap.preload.resource).push.apply(_a, resolveParams.preloadResArr);
            }
            var _a;
        }, function (error) {
            return Promise.reject(error);
        }));
    };
    /**
     * Input: IOMap JSON
     * @param attrObj: it's an object having the following
     * IOMap, stepUIState,
     * skillRef (object of skill specific class. It was generated by skill factory),
     * taskId, stepIndex and reference of dbFilestoreMgr
     * Output: Attribute value map Json
     */
    IOTranslator.prototype.readIOMap = function (attrObj) {
        var _this = this;
        var iomap = attrObj.IOMap;
        return attrObj.skillRef["init"](attrObj).then(function () {
            var self = _this, PromiseRequestsArr = [], resourceMap = {};
            /**
             * Recursive function to traverse the IO Map to translate IO Map into Attribute Value Map
             */
            (function traverseIOMap(parentObj, keyName, stateId, compId) {
                for (var key in parentObj[keyName]) {
                    //Get StateID and CompID
                    switch (keyName) {
                        case "states":
                            stateId = key;
                            break;
                        case "components":
                            compId = key;
                            break;
                        default:
                            break;
                    }
                    // if check to ensure that this iteration is for an element in which some translation has to be done
                    // and not for some element in the hierarchy which doesn't need any translation for itself but has some child elements
                    if (key === "function-name") {
                        self._executeIOMapFunction(attrObj, { parentObj: parentObj, keyName: keyName, stateId: stateId, compId: compId }, PromiseRequestsArr, resourceMap);
                    }
                    else if (typeof parentObj[keyName][key] === "object") {
                        traverseIOMap(parentObj[keyName], key, stateId, compId);
                    }
                }
            })({ "iomap": iomap }, "iomap");
            var copyResPromiseArray = _this._copyResourceFilesAndFillPreload(resourceMap, attrObj);
            return Promise.all(PromiseRequestsArr).then(function () {
                iomap.preload.resource = self._removeDuplicatePreloadResources(iomap.preload.resource);
                return Promise.resolve([iomap, copyResPromiseArray]);
            })["catch"](function (err) {
                console.log("Error in traverseIOMap function of IOTranslator: " + err.message);
                return Promise.reject(err);
            });
        })["catch"](function (error) {
            console.log("Error in readIOMap function of IOTranslator: " + error.message);
            return Promise.reject(error);
        });
    };
    /**
     * Input: Preload Resources Array.
     * @param {*} preloadArray : It's an array that contains multiple objects each having file path and
     * file type of preload resource.
     * Output: Array having Unique Preload Resources.
     */
    IOTranslator.prototype._removeDuplicatePreloadResources = function (preloadArray) {
        var tempObj = {};
        return preloadArray.filter(function (obj) {
            return tempObj[obj.path] ? false : tempObj[obj.path] = true;
        });
    };
    /**
     *
     * @param {*} resourceMap : It's an object which contains following key-value pairs:
     *   absFilePath:"XMLs/TaskXmls/go16/wd/12/12b.02.t1/1/Assets/1493790231823.DocumentData.json"
     *   customParentFolder: Any custom folder hierarchy
     *   fileName: "1493790231823.DocumentData.json"
     *   fileType: "json"
     *   resourceType: "step"
     * @param {*} attrObj : it's an object having the following
     * IOMap, stepUIState,
     * skillRef (object of skill specific class. It was generated by skill factory),
     * taskId, stepIndex and reference of dbFilestoreMgr
     *
     * Output: It returns an Array of promises for copying the resource files and also add these resources to
     * Preload Array which will be used for XML generation
     */
    IOTranslator.prototype._copyResourceFilesAndFillPreload = function (resourceMap, attrObj) {
        var copyResPromiseArray = [];
        for (var key in resourceMap) {
            copyResPromiseArray.push(attrObj.dbFilestoreMgr.copyTaskAssetFileEnhanced(key, resourceMap[key], attrObj.taskId, attrObj.stepIndex));
            //Adding in prload Res
            if (!attrObj.IOMap.preload)
                attrObj.IOMap.preload = { resource: [] };
            else if (!attrObj.IOMap.preload.resource)
                attrObj.IOMap.preload.resource = [];
            attrObj.IOMap.preload.resource.push({ "path": resourceMap[key]["absFilePath"], "type": resourceMap[key]["fileType"] });
        }
        return copyResPromiseArray;
    };
    IOTranslator.prototype.getAttrValueMap = function (attrObj) {
        return this.readIOMap(attrObj).then(function (_a) {
            var ioMap = _a[0], copyResPromiseArray = _a[1];
            return Promise.resolve([ioMap, copyResPromiseArray]);
        })["catch"](function (error) {
            return Promise.reject(error);
        });
    };
    return IOTranslator;
}());
var iotranslatorobj = new IOTranslator();
module.exports = iotranslatorobj;
